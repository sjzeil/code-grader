package edu.odu.cs.zeil.codegrader.oracle;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.lang.invoke.MethodHandles;
import java.nio.file.Path;
import java.util.Scanner;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import edu.odu.cs.zeil.codegrader.OracleProperties;
import edu.odu.cs.zeil.codegrader.Stage;
import edu.odu.cs.zeil.codegrader.Submission;
import edu.odu.cs.zeil.codegrader.TestCase;

/**
 * An oracle that ignores the expected string and scans the observed string
 * for a JUnit 5 report, as generated by running junit-platform-console-*.jar.
 * 
 * E.g.,
 * 
 * <pre>
 * Test run finished after 64 ms
 * [         3 containers found      ]
 * [         0 containers skipped    ]
 * [         3 containers started    ]
 * [         0 containers aborted    ]
 * [         3 containers successful ]
 * [         0 containers failed     ]
 * [        10 tests found           ]
 * [         0 tests skipped         ]
 * [        10 tests started         ]
 * [         0 tests aborted         ]
 * [         6 tests successful      ]
 * [         4 tests failed          ]
 * </pre>
 * 
 * The score is the ratio of successful tests to started tests.
 * 
 * @author zeil
 *
 */
public class JUnit5Oracle extends Oracle {

    private static final String STARTED_STRING = "tests started";
    private static final String PASSED_STRING = "tests successful";

    private static final double PERFECT_SCORE = 100.0;

    private Path gradleTestReport;
    private Path mavenTestReport;

    /**
     * Error logging.
     */
    private static Logger logger = LoggerFactory.getLogger(
            MethodHandles.lookup().lookupClass());

    /**
     * Create a new oracle.
     * 
     * @param config         configuration properties
     * @param testCase       the test case to which this oracle will apply
     * @param submission     the submission being judged
     * @param submitterStage the stage where the submitted code has been built
     */
    public JUnit5Oracle(OracleProperties config, TestCase testCase,
            Submission submission, Stage submitterStage) {
        super(config, testCase, submission, submitterStage);
        gradleTestReport = submitterStage.getStageDir()
                .resolve("build/reports/tests/test/index.html");
        mavenTestReport = submitterStage.getStageDir()
                .resolve("target/surefire-reports/");
    }

    /**
     * Compare two strings to see if one is an acceptable variant of the other.
     * The precise meaning of "acceptable" depends on the settings.
     * 
     * @param expected the expected string
     * @param actual   the string being examined
     * @return true if actual is an acceptable variant of expected.
     */
    @Override
    public OracleResult compare(String expected, String actual) {
        try (BufferedReader observed = new BufferedReader(new StringReader(actual))) {
            String line = observed.readLine();
            int nStarted = -1;
            int nSuccessful = -1;
            while (line != null) {
                if (line.contains(STARTED_STRING)) {
                    nStarted = extractNumber(line);
                } else if (line.contains(PASSED_STRING)) {
                    nSuccessful = extractNumber(line);
                }
                if (nStarted >= 0 && nSuccessful >= 0) {
                    break;
                }
                line = observed.readLine();
            }
            if (nStarted > 0 && nSuccessful >= 0) {
                double score = (PERFECT_SCORE
                        * (double) nSuccessful) / ((double) nStarted);
                return new OracleResult((int) Math.round(score), actual);
            } else if (gradleTestReport.toFile().exists()) {
                // Parse a gradle-generated JUnit test report
                return parseGradleReport();
            } else if (mavenTestReport.toFile().exists()) {
                return parseMavenReport();
            } else {
                logger.warn("Oracle could not parse test report");
                return new OracleResult(0,
                        "Could not parse test report.\n(Code had compilation errors or crashed before tests could be run.)");
            }
        } catch (IOException ex) {
            logger.warn("Oracle could not read test report", ex);
            return new OracleResult(0, "Could not read test report.\n(Tests were not run?)");
        }
    }

    private OracleResult parseMavenReport() {
        int nCases = 0;
        int nFailures = 0;

        for (File f: mavenTestReport.toFile().listFiles(
          (d,fn) -> {return true;})) {
            try (BufferedReader in = new BufferedReader(new FileReader(f))) {
                String line = in.readLine();
                while (line != null) {
                    if (line.startsWith("Tests run:")) {
                        Scanner scan = new Scanner(line);
                        scan.useDelimiter("[ ,:]+");
                        String t = scan.next(); // Tests
                        t = scan.next(); // run:
                        int nr = scan.nextInt();
                        t = scan.next(); // Failures: 
                        int nf = scan.nextInt();
                        scan.next(); // Errors: 
                        int ne = scan.nextInt();
                        nCases += nr;
                        nFailures += nf + ne;
                        scan.close();
                    }
                    line = in.readLine();
                }
            } catch (IOException e) {
                logger.warn("Unable to parse test report in"
                + f.toString(), e);
                return new OracleResult(0, "Unable to parse test report in"
                        + f.toString());
            }      
        }
        if (nCases == 0)
            return new OracleResult(0, "Found no test reports in "
              + mavenTestReport.toString());
        else {
            double pct = 100.0 - (100.0 * (nFailures)) / (nCases);
            int score = (int)Math.round(pct);
            return new OracleResult(score, "Passed " + (nCases - nFailures) 
                + " out of " + nCases + " tests." );
        }
    }

    private OracleResult parseGradleReport() {
        StringBuffer details = new StringBuffer();
        try (BufferedReader in = new BufferedReader(new FileReader(gradleTestReport.toFile()))) {
            String line = in.readLine();
            boolean listing = false;
            int score = -1;
            while (line != null) {
                if (line.contains("class=\"percent\"")) {
                    line = line.substring(line.indexOf('>') + 1);
                    line = line.substring(0, line.indexOf('%'));
                    score = Integer.parseInt(line);
                }
                if (line.contains("<h2>Failed tests")) {
                    listing = true;
                } else if (line.contains("</div>")) {
                    listing = false;
                } else if (listing && line.contains("()")) {
                    line = line.substring(line.indexOf('>') + 1);
                    line = "Failed test: " + line.substring(0, line.indexOf('<'));
                    details.append(line);
                    details.append("\n");
                }
                line = in.readLine();
            }
            if (score >= 0) {
                return new OracleResult(score, details.toString());
            } else {
                return new OracleResult(0, "Unable to parse "
                        + gradleTestReport.toString());
            }
        } catch (IOException e) {
            logger.warn("Oracle could not parse test report", e);
            return new OracleResult(0, "Unable to read "
                        + gradleTestReport.toString());
        }
    }

    private int extractNumber(String line) {
        java.util.Scanner in = new java.util.Scanner(line);
        int result = 0;
        while (in.hasNext() && !in.hasNextInt()) {
            in.next();
        }
        if (in.hasNextInt()) {
            result = in.nextInt();
        }
        in.close();
        return result;
    }

}
